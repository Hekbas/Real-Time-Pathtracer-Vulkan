#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable

#include "common.glsl"

void main() {
    // pixel coordinates
    uvec2 launchID = gl_LaunchIDEXT.xy;
    uvec2 launchSize = gl_LaunchSizeEXT.xy;
    ivec2 pix = ivec2(launchID);

    // build RNG seed unique per pixel+frame
    uint seed = uint(launchID.x) * 1973u + uint(launchID.y) * 9277u + uint(pc.frame) * 2663u;
    seed = wang_hash(seed);

    // subpixel jitter
    float rx = rnd(seed);
    float ry = rnd(seed);

    // normalized device coords in [-1,1], y flipped so +Y is up on screen
    float ndcX = ( (float(launchID.x) + rx) / float(launchSize.x) - 0.5 ) * 2.0;
    float ndcY = ( 0.5 - (float(launchID.y) + ry) / float(launchSize.y) ) * 2.0;

    // assume pc.cameraRight / cameraUp are already scaled to the camera frustum (screen plane extents)
    vec3 origin = pc.cameraPos;
    vec3 direction = normalizeSafe(pc.cameraFront + ndcX * pc.cameraRight + ndcY * pc.cameraUp);

    // init payload
    payload.radiance = vec3(0.0);
    payload.throughput = vec3(1.0);
    payload.seed = seed;
    payload.depth = 0;
    payload.pad = 0; // miss

    uint  rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin     = 0.001;
    float tMax     = 10000.0;

    // Trace primary ray. missIndex = 1 (matches pipeline groups: 0=raygen,1=miss,2=hit)
    // rayFlags=0, cullMask=0xFF, sbtRecordOffset=0, sbtRecordStride=0
    traceRayEXT(
        topLevelAS,     // acceleration structure
        rayFlags,       // rayFlags
        0xFF,           // cullMask
        0,              // sbtRecordOffset
        0,              // sbtRecordStride
        0,              // missIndex
        origin.xyz,     // ray origin
        tMin,           // ray min range
        direction.xyz,  // ray direction
        tMax,           // ray max range
        0               // payload (location = 0)
    );

    // payload.radiance now contains returned radiance (closesthit / miss must write it)
    vec3 radianceSample = payload.radiance;

    // Read previous pixel (assume it's stored as sRGB in the storage image)
    vec4 prevTex = imageLoad(imgOutput, pix);
    vec3 prevLinear = srgb_to_linear(prevTex.rgb);

    // running average: new = (prev * frame + sample) / (frame+1)
    float f = float(max(pc.frame, 0));
    vec3 accumLinear = (prevLinear * f + radianceSample) / (f + 1.0);

    // convert to sRGB for storage and write
    vec3 outSRGB = linear_to_srgb(accumLinear);
    imageStore(imgOutput, pix, vec4(outSRGB, 1.0));

    // TESTs
    //ivec2 px = ivec2(gl_LaunchIDEXT.xy);
    //imageStore(imgOutput, px, vec4(1.0, 0.0, 0.0, 1.0)); // solid red

    // Debug: Green for hit, blue for miss
    // vec3 color = payload.pad == 1 ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);
    // imageStore(imgOutput, pix, vec4(color, 1.0));
}
