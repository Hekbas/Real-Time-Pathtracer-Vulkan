#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable
#include "common.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D outputImage;

layout(push_constant) uniform PushConstants {
    int frame;
    vec3 cameraPos;
    vec3 cameraFront;
    vec3 cameraUp;
    vec3 cameraRight;
} pc;

layout(location = 0) rayPayloadEXT HitPayload payload;

void createCoordinateSystem(in vec3 N, out vec3 T, out vec3 B) {
    if(abs(N.x) > abs(N.y))
        T = vec3(N.z, 0, -N.x) / sqrt(N.x * N.x + N.z * N.z);
    else
        T = vec3(0, -N.z, N.y) / sqrt(N.y * N.y + N.z * N.z);
    B = cross(N, T);
}

vec3 sampleHemisphere(float rand1, float rand2) {
    vec3 dir;
    dir.x = cos(2 * M_PI * rand2) * sqrt(1 - rand1 * rand1);
    dir.y = sin(2 * M_PI * rand2) * sqrt(1 - rand1 * rand1);
    dir.z = rand1;
    return dir;
}

vec3 sampleDirection(float rand1, float rand2, vec3 normal) {
    vec3 tangent;
    vec3 bitangent;
    createCoordinateSystem(normal, tangent, bitangent);
    vec3 dir = sampleHemisphere(rand1, rand2);
    return dir.x * tangent + dir.y * bitangent + dir.z * normal;
}

vec3 random_in_unit_sphere(inout uint seed) {
    vec3 p;
    do {
        p = 2.0 * vec3(rand(seed), rand(seed), rand(seed)) - vec3(1.0);
    } while (dot(p, p) >= 1.0);
    return p;
}

// Schlick's approximation for Fresnel effect
float schlick(float cosine, float ref_idx) {
    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);
    r0 = r0 * r0;
    return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);
}

void main()
{
    // SPP for anti-aliasing
    int maxSamples = 4;
    vec3 color = vec3(0.0);
    for(uint sampleNum = 0; sampleNum < maxSamples; sampleNum++) {
        // Unique random seed per sample/frame
        uvec2 s = pcg2d(ivec2(gl_LaunchIDEXT.xy) * (sampleNum + maxSamples * pc.frame + 1));
        uint seed = s.x + s.y;

        // Calc ray + AA Jitter
        const vec2 screenPos = vec2(gl_LaunchIDEXT.xy) + vec2(rand(seed), rand(seed));
        const vec2 inUV = screenPos / vec2(gl_LaunchSizeEXT.xy);
        vec2 d = inUV * 2.0 - 1.0;
        float aspect_ratio = float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);
        float fov = 70.0; 
        float tan_fov = tan(radians(fov * 0.5));
        vec3 rayDir = normalize(
            pc.cameraFront +
            pc.cameraRight * d.x * aspect_ratio * tan_fov +
            pc.cameraUp    * d.y * tan_fov
        );

        // Initial ray properties
        vec3 origin    = pc.cameraPos;
        vec3 direction = rayDir;
        vec3 weight = vec3(5.0);
        payload.done = false;

        // --- Path Tracing Loop ---
        for(uint depth = 0; depth < 8; depth++) {
            traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, 0.001, direction, 10000.0, 0);

            // Add emitted light from hit surface (or sky)
            color += weight * payload.emission;

            if(payload.done) {
                break;
            }

            // Prepare for next bounce
            origin = payload.position;
            vec3 attenuation;
            vec3 scattered_dir;

            switch(payload.material_type) {
                // --- Case 1: Lambertian (Diffuse) ---
                case MAT_LAMBERTIAN: {
                    scattered_dir = payload.normal + random_in_unit_sphere(seed);
                    attenuation = payload.albedo;
                    weight *= attenuation;
                    direction = normalize(scattered_dir);
                    break;
                }

                // --- Case 2: Metal (Reflective) ---
                case MAT_METAL: {
                    vec3 reflected = reflect(direction, payload.normal);
                    scattered_dir = normalize(reflected + payload.roughness * random_in_unit_sphere(seed));
                    attenuation = payload.albedo;
                    if (dot(scattered_dir, payload.normal) > 0) {
                        weight *= attenuation;
                        direction = scattered_dir;
                    } else {
                        // Ray is absorbed if it scatters below the surface
                        weight = vec3(0.0); 
                    }
                    break;
                }

                // --- Case 3: Dielectric (Refractive) ---
                case MAT_DIELECTRIC: {
                    vec3 incoming_dir = normalize(direction);
                    vec3 outward_normal;
                    float ni_over_nt;
                    float cosine;
                    float reflect_prob;
                    
                    attenuation = vec3(1.0); // Perfect glass doesn't attenuate

                    if (dot(incoming_dir, payload.normal) > 0) { // Ray is inside the medium
                        outward_normal = -payload.normal;
                        ni_over_nt = payload.ior;
                        cosine = payload.ior * dot(incoming_dir, payload.normal);
                    } else { // Ray is outside the medium
                        outward_normal = payload.normal;
                        ni_over_nt = 1.0 / payload.ior;
                        cosine = -dot(incoming_dir, payload.normal);
                    }
                    
                    vec3 refracted = refract(incoming_dir, outward_normal, ni_over_nt);
                    if (refracted != vec3(0.0)) { // Check for total internal reflection
                        reflect_prob = schlick(cosine, payload.ior);
                    } else {
                        reflect_prob = 1.0;
                    }

                    if (rand(seed) < reflect_prob) {
                        direction = reflect(incoming_dir, payload.normal);
                    } else {
                        direction = refracted;
                    }
                    weight *= attenuation;
                    break;
                }
            }
            
            // Terminate ray if its contribution is negligible
            if(max(weight.x, max(weight.y, weight.z)) < 0.01){
                break;
            }
        }
    }
    color /= maxSamples;
    
    // Temporal accumulation
    vec4 oldColor = imageLoad(outputImage, ivec2(gl_LaunchIDEXT.xy));
    vec4 newColor = (vec4(color, 1.0) + (oldColor * pc.frame)) / (pc.frame + 1);
    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), newColor);
}