#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable
#include "common.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D accumImage;   // linear float accumulation buffer
layout(binding = 2, set = 0, rgba8)   uniform image2D outputImage;  // final display buffer (gamma applied)

layout(push_constant) uniform PushConstants {
    int frame;
    vec3 cameraPos;
    vec3 cameraFront;
    vec3 cameraUp;
    vec3 cameraRight;
} pc;

layout(location = 0) rayPayloadEXT HitPayload payload;

void main()
{
    ivec2 pix = ivec2(gl_LaunchIDEXT.xy);
    ivec2 size = ivec2(gl_LaunchSizeEXT.xy);

    const int maxSamples = 4; // spp per frame
    vec3 sampleAccum = vec3(0.0);

    for (uint s = 0u; s < uint(maxSamples); ++s) {
        // RNG seed
        uvec2 seed2 = pcg2d(ivec2(gl_LaunchIDEXT.xy) * (int(s) + maxSamples * pc.frame + 1));
        uint seed = seed2.x ^ seed2.y;

        // jittered AA
        vec2 jitter = vec2(rand(seed), rand(seed));
        vec2 inUV = (vec2(pix) + jitter) / vec2(size);
        vec2 d = inUV * 2.0 - 1.0;
        float aspect = float(size.x) / float(size.y);
        float fov = 70.0;
        float tanFov = tan(radians(fov * 0.5));
        vec3 rayDir = normalize(
            pc.cameraFront +
            pc.cameraRight * d.x * aspect * tanFov +
            pc.cameraUp    * d.y * tanFov
        );

        // Path state
        vec3 origin = pc.cameraPos;
        vec3 direction = rayDir;
        vec3 throughput = vec3(1.0);
        vec3 radiance = vec3(0.0);

        // Path tracing loop
        for (int depth = 0; depth < 6; ++depth) {
            traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0,
                        origin, 0.001, direction, 1e20, 0);

            radiance += throughput * payload.emission;
            if (payload.done) break;

            // shading basis
            vec3 N = normalize(payload.normal);
            vec3 V = normalize(-direction);
            vec3 albedo = payload.albedo;
            float metallic = payload.metallic;
            float roughness = payload.roughness;

            // alpha test
            if (payload.alpha < 0.99 && rand(seed) > payload.alpha) {
                origin = payload.position + direction * 0.001;
                continue;
            }

            // Dielectric (refraction)
            if (payload.material_type == MAT_DIELECTRIC) {
                vec3 I = normalize(direction);
                vec3 Nl = N;
                float eta = payload.ior;
                float cosi = dot(I, N);
                float ni_over_nt = (cosi > 0.0) ? eta : 1.0 / eta;
                if (cosi > 0.0) Nl = -N;

                vec3 refr = refract(I, Nl, ni_over_nt);
                float reflectProb = saturate(schlickFresnel(abs(cosi), 0.04));
                if (refr == vec3(0.0) || rand(seed) < reflectProb)
                    direction = reflect(I, N);
                else
                    direction = refr;

                origin = payload.position + direction * 0.001;
                continue;
            }

            // Sample diffuse or specular
            float chooseSpec = rand(seed);
            vec3 Lsample;
            float pdf = 1.0;
            if (chooseSpec < clamp(metallic + (1.0 - roughness) * 0.5, 0.0, 1.0)) {
                Lsample = sampleGGX(N, V, roughness, seed);
                pdf = max(pdfGGX(N, V, Lsample, roughness), 1e-6);
            } else {
                Lsample = sampleCosineHemisphere(N, seed);
                pdf = max(pdfCosineHemisphere(max(dot(N, Lsample), 0.0)), 1e-6);
            }

            float NdotL = max(dot(N, Lsample), 0.0);
            if (NdotL <= 0.0) break;

            vec3 f = evalBRDF(N, V, Lsample, albedo, metallic, roughness);

            direction = normalize(Lsample);
            origin = payload.position + direction * 0.001;
            throughput *= f * (NdotL / pdf);

            // Russian roulette
            if (depth > 3) {
                float p = clamp(max(throughput.r, max(throughput.g, throughput.b)), 0.05, 0.95);
                if (rand(seed) > p) break;
                throughput /= p;
            }
            if (max(throughput.r, max(throughput.g, throughput.b)) < 1e-4) break;
        }

        sampleAccum += radiance;
    }

    sampleAccum /= float(maxSamples); // avg this frameâ€™s spp

    // --- Temporal accumulation (keep in linear) ---
    vec4 prev = imageLoad(accumImage, pix);
    vec3 linearAccum = (prev.rgb * float(pc.frame) + sampleAccum) / float(pc.frame + 1);
    imageStore(accumImage, pix, vec4(linearAccum, 1.0));

    // --- Final display with gamma correction (only once) ---
    vec3 display = pow(linearAccum, vec3(1.0 / 2.2));
    imageStore(outputImage, pix, vec4(display, 1.0));
}